# 变量和基本类型

## 内置类型的机器实现

计算机可寻址的最小内存块称为“字节(byte)”，存储的基本单元称为“字(word)”。大多数机器的字节由8比特构成，字则由32或64比特构成，也就是4或8字节。

## 类型选择

- 当明确知晓数值不可能为负时，选用无符号类型;
- 在实际应用中，short范围很小而long一般和int有一样的尺寸，所以在数值超过了int的表示范围时，直接选择long long;
- 在算术表达式中不要使用char或bool，只有在存放字符或布尔值时才使用它们。因为类型char在一些机器上是有符号的，而在另一些机器上又是无符号的，所以如果要使用char进行运算很容易出问题。如果你必须使用一个不大的整数，可以明确指定它的类型是signed char 或者unsigned char。

## 类型转换

对象的类型定义了对象能包含的数据和能参与的运算。类型所能表示的值的范围决定了转换的过程：

- 当我们把一个非布尔类型的算术值赋值给布尔类型时，初始值为0则结果为`fasle`，否则结果为`true`.
- 当我们把一个布尔值赋给非布尔类型时，初始值为`fasle`则结果为0,初始值为`true`则结果为1.
- 当我们把一个浮点数赋给整数类型时，进行近似处理。结果值将仅保留浮点数中小数点之前的部分。
- 当我们把一个整数值赋给浮点类型时，小数部分记为0。如果该整数所占的空间超过了浮点类型的容量，精度可能有损失。
- 当我们赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。
- 当我们赋给带符号类型一个超出它表示范围的值时，结果是未定义的(undefined)。

```c++
bool b = 42;	// b为真
int i = b;		// i的值为1
i = 3.14；		// i的值为3
double pi = i;	// pi的值为3.0
unsigned char c = -1;	// 假设char占8比特，c的值为255
signed char c2 = 256;	// 假设char占8比特，c2的值是未定义的
```



**！避免无法预知和依赖于实现环境的行为, 切勿混用带符号类型和无符号类型**

无法预知的行为源于编译器无须(有时是不能)检测的错误。即使代码编译通过了，如果程序执行了一条未定义的表达式，可能正确执行，也可能产生错误；程序也应该尽量避免依赖于实现环境的行为，否则程序是不可移植的(nonportable)。

## 变量

变量提供一个具名的、可供程序操作的存储空间。数据类型决定着变量所占的内存空间的大小和布局方式，该空间能存储的值的范围，以及变量能参与的运算。

## 符合类型

### 引用

引用(reference)为对象起了另外一个名字，通过将声明符&申明。

```c++
int ival = 1024;
int &refval = ival;	// refval指向ival(是ival的另外一个名字)
int &refval2;	// 报错：引用必须被初始化
```

初始化变量时，初始值会被拷贝到新建的对象中；但是定义引用时，程序把引用和它的初始值绑定(bind)在一起，而不是将初始值拷贝给应用。**一旦初始化完成，引用将和它的初始值一直绑定在一起，不能重新绑定到另外一个对象。**

除了两种例外情况，其他所有引用类型都要和与之绑定的对象严格匹配，而且，引用只能绑定在对象上，不能与字面值或某个表达值的计算结果绑定在一起。

### 指针

指针是“指向”另外一种类型的复合类型。

### 指针与引用的不同点

- 指针本身是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内，他可以先后指向几个不同的对象;
- 指针无需在定义时赋初值。在块作用域内定义的指针如果没有初始化，也将拥有一个不确定的值。



