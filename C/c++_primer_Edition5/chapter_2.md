# 变量和基本类型

## 内置类型的机器实现

计算机可寻址的最小内存块称为“字节(byte)”，存储的基本单元称为“字(word)”。大多数机器的字节由8比特构成，字则由32或64比特构成，也就是4或8字节。

## 类型选择

- 当明确知晓数值不可能为负时，选用无符号类型;
- 在实际应用中，short范围很小而long一般和int有一样的尺寸，所以在数值超过了int的表示范围时，直接选择long long;
- 在算术表达式中不要使用char或bool，只有在存放字符或布尔值时才使用它们。因为类型char在一些机器上是有符号的，而在另一些机器上又是无符号的，所以如果要使用char进行运算很容易出问题。如果你必须使用一个不大的整数，可以明确指定它的类型是signed char 或者unsigned char。

## 类型转换

对象的类型定义了对象能包含的数据和能参与的运算。类型所能表示的值的范围决定了转换的过程：

- 当我们把一个非布尔类型的算术值赋值给布尔类型时，初始值为0则结果为`fasle`，否则结果为`true`.
- 当我们把一个布尔值赋给非布尔类型时，初始值为`fasle`则结果为0,初始值为`true`则结果为1.
- 当我们把一个浮点数赋给整数类型时，进行近似处理。结果值将仅保留浮点数中小数点之前的部分。
- 当我们把一个整数值赋给浮点类型时，小数部分记为0。如果该整数所占的空间超过了浮点类型的容量，精度可能有损失。
- 当我们赋给无符号类型一个超出它表示范围的值时，结果是初始值对无符号类型表示数值总数取模后的余数。
- 当我们赋给带符号类型一个超出它表示范围的值时，结果是未定义的(undefined)。

```c++
bool b = 42;	// b为真
int i = b;		// i的值为1
i = 3.14；		// i的值为3
double pi = i;	// pi的值为3.0
unsigned char c = -1;	// 假设char占8比特，c的值为255
signed char c2 = 256;	// 假设char占8比特，c2的值是未定义的
```



**！避免无法预知和依赖于实现环境的行为, 切勿混用带符号类型和无符号类型**

无法预知的行为源于编译器无须(有时是不能)检测的错误。即使代码编译通过了，如果程序执行了一条未定义的表达式，可能正确执行，也可能产生错误；程序也应该尽量避免依赖于实现环境的行为，否则程序是不可移植的(nonportable)。

## 变量

变量提供一个具名的、可供程序操作的存储空间。数据类型决定着变量所占的内存空间的大小和布局方式，该空间能存储的值的范围，以及变量能参与的运算。

## 符合类型

### 引用

引用(reference)为对象起了另外一个名字，通过将声明符&申明。

```c++
int ival = 1024;
int &refval = ival;	// refval指向ival(是ival的另外一个名字)
int &refval2;	// 报错：引用必须被初始化
```

初始化变量时，初始值会被拷贝到新建的对象中；但是定义引用时，程序把引用和它的初始值绑定(bind)在一起，而不是将初始值拷贝给应用。**! 一旦初始化完成，引用将和它的初始值一直绑定在一起，不能重新绑定到另外一个对象。**

除了两种例外情况(*初始化常量引用时*)，其他所有引用类型都要和与之绑定的对象严格匹配，而且，引用只能绑定在对象上，不能与字面值或某个表达值的计算结果绑定在一起。

#### 两种特例情况

- 初始化常量引用时允许使用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可；允许为一个常量引用绑定非常量的对象、字面值，甚至是个一般表达式：

```c++
int i = 42;
const int &r1 = i;	// 允许将const int&绑定到一个普通int对象上
const int &r2 = 42;	// 42是一个字面值
const int &r3 = r1 * 2;	// 正确：r3是一个常量引用
int &r4 = r1 * 2;	// 错误：r4是一个普通的非常量引用
```

**特例情况的原因：**

当一个常量引用被绑定到另外一种类型上时发生了什么？

```c++
double dval = 3.14;
const int &ri = dval;
```

此处`ri` 引用了一个`int`型的数。对`ri`的操作应该是整数运算，但`dval`却是一个双精度浮点数而非整数。因此为了确保让`ri`绑定一个整数，编译器把上述代码变成了如下形式：

```c++
const int temp = dval;	// 由双精度浮点数生成一个临时的整型常量
const int &ri = temp;	// 让ri绑定这个临时量（不是dval）
```

**! 临时量(temporary)对象，当编译器需要一个空间来暂存表达式的求值结果时临时创建的一个未命名的对象。**

**! 在c++中，将引用绑定到临时量是非法的**

### 指针

指针是“指向”另外一种类型的复合类型。

### 指针与引用的不同点

- 指针本身是一个对象，允许对指针赋值和拷贝，而且在指针的生命周期内，他可以先后指向几个不同的对象;
- 指针无需在定义时赋初值。在块作用域内定义的指针如果没有初始化，也将拥有一个不确定的值。

## `const`限定符

`const`对象一旦创建后其值就不能再改变，所以`const`对象必须初始化，初始值可以是任意复杂的表达式。

默认情况下，`const`对象被设定为仅在文件内有效。当多个文件中出现出现了同名的`const`变量时，等同于在多个不同文件中分别定义了独立的变量。解决办法，对`const`变量不管是定义还是声明都添加`extern`关键字，这样就只需要定义一次:

```c++
// file_1.cc 定义并初始化了一个常量，该常量能被其他文件访问
extern const int bufSize = fcn();
// file_1.h头文件
extern const int bufSize; 	// 与file_1.cc中定义的bufSize是同一个
```

### `const`的引用

将引用绑定到`const`对象上，称为对常量的引用(`reference to const`)

```c++
const int ci = 1024;
const int &r1 = ci;	// 正确：引用及其对象都是常量
r1 = 42;	// 错误：r1是对常量的引用，而且引用不能和字面量绑定
int &r2 = ci;	// 错误： 试图让一个非常量引用指向一个常量对象
```

**! 常量引用仅对引用可参与的操作作出了限定，对于引用的对象本身是不是一个常量未作限定。**

```c++
int i = 42;
int &r1 = i;	// 引用r1绑定对象i
const int &r2 = i; // r2也绑定对象i，但不允许通过r2修改i的值
r1 = 0;	// r1并非常量，i的值可以改变为0
r2 = 0;	// 错误：r2是一个常量引用
```

### 指针和`const`

指向常量的指针(`pointer to const`)不能用于改变其所指对象的值。

存放常量对象的地址，只能使用指向常量的指针;

指向常量的指针仅仅要求不能通过该指针改变对象的值，而没有规定所指的对象必须是一个常量。

```c++
const double pi = 3.14;
double *ptr = &pi;	// 错误：ptr是一个普通指针
const double *cptr = &pi;	// 正确：cptr可以指向一个双精度常量
*cptr = 42;	//错误：指向常量的指针不能用于改变其所指对象的值
```

#### `const`指针

常量指针(`const pointer`)必须初始化，初始化后的值不能改变。

顶层`const`表示指针本身是一个常量，底层`const`表示指针指向的对象是一个常量。

顶层`const`可以表示任意的对象是常量，而底层`const`则与指针和引用等复合类型的基本类型部分有关。

**！一般来说，非常量可以转换成常量，反之则不行。**


